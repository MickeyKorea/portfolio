let group, container, stats; const particlesData = []; let camera, scene, renderer, positions, colors, particles, pointCloud, particlePositions, linesMesh; const maxParticleCount = 1e3; let particleCount = 500; const r = 800, rHalf = 400, effectController = { showDots: !0, showLines: !0, minDistance: 150, limitConnections: !1, maxConnections: 20, particleCount: 500 }; function initGUI() { const e = new GUI; e.add(effectController, "showDots").onChange((function (e) { pointCloud.visible = e })), e.add(effectController, "showLines").onChange((function (e) { linesMesh.visible = e })), e.add(effectController, "minDistance", 10, 300), e.add(effectController, "limitConnections"), e.add(effectController, "maxConnections", 0, 30, 1), e.add(effectController, "particleCount", 0, 1e3, 1).onChange((function (e) { particleCount = e, particles.setDrawRange(0, particleCount) })) } function init() { container = document.getElementById("container"), camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 4e3), camera.position.z = 1800, scene = new THREE.Scene, group = new THREE.Group, scene.add(group); const e = new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(r, r, r))); e.material.color.setHex(4671303), e.material.blending = THREE.AdditiveBlending, e.material.transparent = !0, group.add(e); positions = new Float32Array(3e6), colors = new Float32Array(3e6); const t = new THREE.PointsMaterial({ color: 16777215, size: 3, blending: THREE.AdditiveBlending, transparent: !0, sizeAttenuation: !1 }); particles = new THREE.BufferGeometry, particlePositions = new Float32Array(3e3); for (let e = 0; e < 1e3; e++) { const t = Math.random() * r - 400, n = Math.random() * r - 400, i = Math.random() * r - 400; particlePositions[3 * e] = t, particlePositions[3 * e + 1] = n, particlePositions[3 * e + 2] = i, particlesData.push({ velocity: new THREE.Vector3(2 * Math.random() - 1, 2 * Math.random() - 1, 2 * Math.random() - 1), numConnections: 0 }) } particles.setDrawRange(0, particleCount), particles.setAttribute("position", new THREE.BufferAttribute(particlePositions, 3).setUsage(THREE.DynamicDrawUsage)), pointCloud = new THREE.Points(particles, t), group.add(pointCloud); const n = new THREE.BufferGeometry; n.setAttribute("position", new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage)), n.setAttribute("color", new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage)), n.computeBoundingSphere(), n.setDrawRange(0, 0); const i = new THREE.LineBasicMaterial({ vertexColors: !0, blending: THREE.AdditiveBlending, transparent: !0 }); linesMesh = new THREE.LineSegments(n, i), group.add(linesMesh), renderer = new THREE.WebGLRenderer({ antialias: !0 }), renderer.setPixelRatio(window.devicePixelRatio), renderer.setSize(window.innerWidth, window.innerHeight), renderer.setAnimationLoop(animate), container.appendChild(renderer.domElement), window.addEventListener("resize", onWindowResize) } function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight, camera.updateProjectionMatrix(), renderer.setSize(window.innerWidth, window.innerHeight) } function animate() { let e = 0, t = 0, n = 0; for (let e = 0; e < particleCount; e++)particlesData[e].numConnections = 0; for (let i = 0; i < particleCount; i++) { const o = particlesData[i]; if (particlePositions[3 * i] += o.velocity.x, particlePositions[3 * i + 1] += o.velocity.y, particlePositions[3 * i + 2] += o.velocity.z, (particlePositions[3 * i + 1] < -rHalf || particlePositions[3 * i + 1] > rHalf) && (o.velocity.y = -o.velocity.y), (particlePositions[3 * i] < -rHalf || particlePositions[3 * i] > rHalf) && (o.velocity.x = -o.velocity.x), (particlePositions[3 * i + 2] < -rHalf || particlePositions[3 * i + 2] > rHalf) && (o.velocity.z = -o.velocity.z), !(effectController.limitConnections && o.numConnections >= effectController.maxConnections)) for (let r = i + 1; r < particleCount; r++) { const s = particlesData[r]; if (effectController.limitConnections && s.numConnections >= effectController.maxConnections) continue; const a = particlePositions[3 * i] - particlePositions[3 * r], l = particlePositions[3 * i + 1] - particlePositions[3 * r + 1], c = particlePositions[3 * i + 2] - particlePositions[3 * r + 2], p = Math.sqrt(a * a + l * l + c * c); if (p < effectController.minDistance) { o.numConnections++, s.numConnections++; const a = 1 - p / effectController.minDistance; positions[e++] = particlePositions[3 * i], positions[e++] = particlePositions[3 * i + 1], positions[e++] = particlePositions[3 * i + 2], positions[e++] = particlePositions[3 * r], positions[e++] = particlePositions[3 * r + 1], positions[e++] = particlePositions[3 * r + 2], colors[t++] = a, colors[t++] = a, colors[t++] = a, colors[t++] = a, colors[t++] = a, colors[t++] = a, n++ } } } linesMesh.geometry.setDrawRange(0, 2 * n), linesMesh.geometry.attributes.position.needsUpdate = !0, linesMesh.geometry.attributes.color.needsUpdate = !0, pointCloud.geometry.attributes.position.needsUpdate = !0, render() } function render() { const e = .001 * Date.now(); group.rotation.y = .1 * e, renderer.render(scene, camera) } init();