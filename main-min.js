THREE.ColorManagement.enabled = !0; const fontLoader = new FontLoader, turn_gui = !1; let y_offset = .6; const canvas = document.querySelector("canvas"), scene = new THREE.Scene; scene.background = new THREE.Color(1512982); const sizes = { width: window.innerWidth, height: window.innerHeight }, FOV_SETTINGS = { mobile: 90, desktop: 70, transitionDuration: .2 }; let targetFov = 70, isTransitioning = !1, transitionStartTime = 0, startFov = 70; const camera = new THREE.PerspectiveCamera(70, sizes.width / sizes.height, .1, 1e3); camera.zoom = 1.1, camera.updateProjectionMatrix(), camera.position.set(0, 4, -5.5), scene.add(camera); const darkmode = 16777215, lightmode = 16711605, intensity = 1.7, width = 6, height = 2.85, rectAreaLight = new THREE.RectAreaLight(16777215, 1.7, 6, 2.85); rectAreaLight.height = 0, rectAreaLight.position.y = -.65 + y_offset, rectAreaLight.position.z = 2, rectAreaLight.rotation.x = -.8; const rectAreaLightHelper = new RectAreaLightHelper(rectAreaLight); scene.add(rectAreaLight, rectAreaLightHelper); const renderer = new THREE.WebGLRenderer({ canvas: canvas }); renderer.outputColorSpace = THREE.LinearSRGBColorSpace, renderer.setSize(sizes.width, sizes.height), renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); const controls = new OrbitControls(camera, canvas); canvas.style.touchAction = "pan-y", controls.enableZoom = !1, controls.minAzimuthAngle = Math.PI - Math.PI / 4, controls.maxAzimuthAngle = Math.PI + Math.PI / 4, controls.minPolarAngle = Math.PI / 3, controls.maxPolarAngle = Math.PI / 2.5, controls.enableDamping = !0, controls.dampingFactor = .02, controls.enableDamping = !0; let lastInteractionTime = Date.now(), isResetting = !1; const resetDelay = 1e3, resetDuration = 1e3; let resetStartTime, resetStartPosition = new THREE.Vector3, resetStartTarget = new THREE.Vector3, initialAnimationComplete = !1; const initialCameraPosition = new THREE.Vector3(0, 4, -5.5), initialTarget = new THREE.Vector3(0, 0, 0); controls.addEventListener("start", (() => { lastInteractionTime = Date.now(), isResetting = !1 })), controls.addEventListener("end", (() => { lastInteractionTime = Date.now() })); const material = new THREE.MeshStandardMaterial({ roughness: .5, metalness: 0 }), plane = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), material); plane.rotation.x = .5 * -Math.PI, plane.position.y = -.65 + y_offset, plane.color = new THREE.Color(1512982), scene.add(plane); const sphere = new THREE.Mesh(new THREE.SphereGeometry(.5, 32, 32), material); sphere.position.x = -2; const cube = new THREE.Mesh(new THREE.BoxGeometry(.75, .75, .75), material), torus = new THREE.Mesh(new THREE.TorusGeometry(.3, .2, 32, 64), material); torus.position.x = 2; const textMaterial = new THREE.MeshStandardMaterial({ color: 4934475, roughness: .5, metalness: 0 }); let nameMesh, subtitleMesh; fontLoader.load("https://mickeykorea.github.io/portfolio/fonts/sfpro-bold.json", (e => { const t = new TextGeometry("Mickey Oh", { font: e, size: .6, depth: .02, curveSegments: 12, bevelEnabled: !0, bevelThickness: .001, bevelSize: .001, bevelOffset: 0, bevelSegments: 1, letterSpacing: -10 }); nameMesh = new THREE.Mesh(t, textMaterial), t.computeBoundingBox(); const n = t.boundingBox.max.x - t.boundingBox.min.x, i = t.boundingBox.max.y - t.boundingBox.min.y; nameMesh.rotation.y = Math.PI, nameMesh.rotation.x = Math.PI / 2.7, nameMesh.position.x = -n / 2 + n, nameMesh.position.y = -i / 2 + y_offset, scene.add(nameMesh), updateYPositions() })), fontLoader.load("https://mickeykorea.github.io/portfolio/fonts/sfpro-regular.json", (e => { const t = new TextGeometry("Creative Technologist", { font: e, size: .25, depth: .01, curveSegments: 12, bevelEnabled: !0, bevelThickness: .001, bevelSize: .001, bevelOffset: 0, bevelSegments: 1, letterSpacing: -.02 }); subtitleMesh = new THREE.Mesh(t, textMaterial), t.computeBoundingBox(); const n = t.boundingBox.max.x - t.boundingBox.min.x, i = t.boundingBox.max.y - t.boundingBox.min.y; subtitleMesh.rotation.y = Math.PI, subtitleMesh.rotation.x = Math.PI / 2.7, subtitleMesh.position.x = -n / 2 + n, subtitleMesh.position.y = -i / 2 + y_offset, subtitleMesh.position.z = 1, scene.add(subtitleMesh), updateYPositions() })); const clock = new THREE.Clock; let isLightAnimationComplete = !1; const lightAnimationDuration = 2; let initialAnimationEndTime = 0; const initialResetDelay = 1e3, update = () => { const e = clock.getElapsedTime(); if (e <= 1.3) { const t = Math.min(e / 1.3, 1); camera.position.z = 1.3 * t - 7 } else initialAnimationComplete || (initialAnimationComplete = !0, initialCameraPosition.copy(camera.position)); if (initialAnimationComplete && (!isResetting && Date.now() - lastInteractionTime > 1e3 && (isResetting = !0, resetStartTime = Date.now(), resetStartPosition.copy(camera.position), resetStartTarget.copy(controls.target)), isResetting)) { const e = Math.min((Date.now() - resetStartTime) / 1e3, 1), t = easeOutCubic(e); camera.position.lerpVectors(resetStartPosition, initialCameraPosition, t), controls.target.lerpVectors(resetStartTarget, initialTarget, t), controls.update(), 1 === e && (isResetting = !1) } if (!isLightAnimationComplete) { const t = Math.min(e / 2, 1), n = 0; rectAreaLight.height = n + (2.85 - n) * t, 1 === t && (isLightAnimationComplete = !0) } if (isTransitioning) { const t = Math.min((e - transitionStartTime) / FOV_SETTINGS.transitionDuration, 1); camera.fov = startFov + (targetFov - startFov) * t, camera.updateProjectionMatrix(), 1 === t && (isTransitioning = !1) } controls.update(), renderer.render(scene, camera), window.requestAnimationFrame(update) }; function easeOutCubic(e) { return 1 - Math.pow(1 - e, 3) } function updateYPositions() { if (plane.position.y = -.65 + y_offset, rectAreaLight.position.y = -.65 + y_offset, nameMesh) { const e = nameMesh.geometry.boundingBox.max.y - nameMesh.geometry.boundingBox.min.y; nameMesh.position.y = -e / 2 + y_offset } if (subtitleMesh) { const e = subtitleMesh.geometry.boundingBox.max.y - subtitleMesh.geometry.boundingBox.min.y; subtitleMesh.position.y = -e / 2 + y_offset } } function responsiveCamera() { const e = window.innerWidth <= 768; e ? (controls.enabled = !1, canvas.style.touchAction = "pan-y", canvas.style.userSelect = "auto") : (controls.enabled = !0, canvas.style.touchAction = "none", canvas.style.userSelect = "none"), y_offset = e ? 1.2 : .6, updateYPositions(); const t = e ? FOV_SETTINGS.mobile : FOV_SETTINGS.desktop; targetFov !== t && (targetFov = t, startFov = camera.fov, isTransitioning = !0, transitionStartTime = clock.getElapsedTime()), camera.aspect = sizes.width / sizes.height, camera.updateProjectionMatrix() } update(), window.addEventListener("resize", (() => { sizes.width = window.innerWidth, sizes.height = window.innerHeight, responsiveCamera(), renderer.setSize(sizes.width, sizes.height), renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)) })), canvas.addEventListener("touchmove", (e => { e.stopPropagation() }), { passive: !1 }), responsiveCamera();